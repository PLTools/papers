\section{Related Works}
\label{sec:related}

The problem of unfair behavior of conjunction in \mk has already been examined from several different points of view. One aspect of the unfair behavior of conjunction is to prioritize the
evaluation of the independent branches which a conjunction generates. In the original \mk a higher priority is given to an earlier branch. However, there is an approach~\cite{fair:towardsAM}
which allows one to balance the evaluation time of different branches. This makes the conjunction behavior fairer, but the order of the conjuncts still affects both the performance and convergence.
Also, the conjunction can be made fairer if we are capable of detecting the divergence in its conjuncts. The approach~\cite{fair:DivTest} detects the divergence at run time and
performs switching of conjuncts. In this case, the data that was received during the evaluation of the diverging conjunct is erased. The approach turned out to be efficient in practice.
However, the conservative rearrangement of the conjuncts does not use the information obtained when evaluating the conjunct before the rearrangement. There are also examples for
this approach where the order of the conjuncts still affects the convergence.

In a broader context of logic programming similar problems were considered multiple number of times as well. It worth mentioning that many results addressing the control
issues in \textsc{Prolog} deal with inherent incompleteness of its depth-first search. For example, in~\cite{Schrijvers2012TorES} a custom disjunction primitive is
introduced which provides a better control on the ``shape'' of the search tree; in~\cite{OLDresolution} tabling is used to provide completeness in a number of cases.
However in \mk with complete search many of addressed problems do not exist. For example, ``The River Crossing Puzzle''\footnote{\url{https://en.wikipedia.org/wiki/River_crossing_puzzle}},
used as an exemplary problem in~\cite{Schrijvers2012TorES}, works in conventional \mk from the beginning.

There is a certain similarity between the problem we address and those arising due to the attempts to come up with a parallelizing \textsc{Prolog} implementation. More concretely, so-called
``dependent AND-parallelism''~\cite{Parallel} also deals with effects caused by variability of conjuncts order evaluation. However, unlike our case, the main efforts there are
aimed at obtaining better performance while preserving the left-to-right depth-first semantics of \textsc{Prolog}. 

In~\cite{Naish1985AutomatingCF} a discipline of delaying certain predicates in current goal to improve the performance/convergence is developed. The approach proposed makes use of two
additional control primitives~--- \emph{wait declarations} and \emph{triggers}~--- to fine-tune the search. Both of these primitives provide additional control on the unification stage
of the search by putting certain constrains on the values the arguments of a predicate acquire after the unification (for example, they can require that a certain argument has to be
bound to a non-variable). If these constrains are violated, the predicate is delayed (it can later be resumed as a result of backtracking). An inference algorithm capable to introduce
reasonable control constraints into a pure logical program is also presented. In comparison with our approach this one looks more local. In addition no fairness result is proven
(or even pursued) even for a limited class of programs. Additionally, no evaluation is presented which would help to provide a mean to compare our approaches (apart from a few simple
examples on which our approach demonstrates the same behavior).
