\section{Evaluation}
\label{sec:eva}

In this section we present an evaluation of the proposed approach. 
We have implemented several relational interpreters for different search problems which can be found in the repository mentioned before. 
Some of the simpler interpreters demonstrate good performance for different directions on their own and for them CPD transformation is not needed. 
Thus, we will focus on two search problems which are more complex: searching for a path in a graph and searching for a unifier~\cite{lozov:unification} of two terms. 
For each problem we compare four programs.
\begin{enumerate}
    \item The solver generated by the unnesting alone.
    \item The solver generated by the unnesting strategy aimed at backward execution. 
    \item The solver generated by the unnesting and then specialized by conjunctive partial deduction for the backward direction.
    \item The interpretation of the functional verifier with the relational interpreter implemented in Scheme~\cite{lozov:seven}. 
\end{enumerate}

First, let us compare the performance of the solvers for the path searching problem.
The implementation of the functional verifier for this problem is described in Section~\ref{sec:example}. 
We ran the search on a graph with 20 nodes and 30 edges, consequentially
 searching for paths of the length 5, 7, 9, 11, 13, and 15. 
We averaged the execution times over 10 runs of the same query. 
We the limited the execution time by 300 seconds, and if the execution time of some query exceeded the timeout, we put ``>300s'' in the result table and did not request the execution of queries for longer paths. The results are presented in Table~\ref{tab:isPath}. 

We can conclude that the execution time increases with the length of the path to search, which is expected, since with the length of the path the number of the subpaths to be explored is increasing as well.
The solver generated by the unnesting alone and the interpretation with the relational intepreter demonstrate poor performance. 
The first one is due to its inherently inefficient execution in backward direction, while the second suffers from the interpretation overhead. 
Both the unnesting aimed at the backward execution and the solver automatically transformed with conjunctive partial deduction show good performance. 
Conjunctive partial deduction performs more thorough specialization, thus producing more efficient program. 

\begin{table}
\centering
\begin{tabular}{c|c|c|c|c|c|c}
Path length                   & 5      & 7     & 9      & 11      & 13     & 15        \\
\hline\hline
Only conversion               & 0.01s  & 1.39s &  82.13s & >300s     & ---      & ---     \\
\hline
Backward oriented conversion  & 0.01s & 0.37s &  2.68s & 2.91s   & 4.88s    & 10.63s   \\
\hline
Conversion and CPD            & 0.01s  & 0.06s &  0.34s & 2.66s   & 3.65s    & 6.22s  \\
\hline
Scheme interpreter            & 0.80s  & 8.22s & 88.14s & 191.44s & >300s   & ---   \\
\end{tabular}

 \caption{Searching for paths in the graph}
    \label{tab:isPath}
\end{table}

Now let us consider the problem of finding a unifier of two terms which have free variables.
A term is either a variable ($X, Y, \dots$) or some constructor applied to terms ($nil, cons(H, T), \dots$). 
A substitution maps a variable to a term. 
A unifier of two terms $t$ and $s$ is a substitution $\sigma$ which equalizes them: $t \sigma = s \sigma$ by simultaneously substituting the variables for their images.
For example, a unifier of the terms $cons(42, X) \text{ and } cons(Y, cons(Y, nil)) \text{ is a substitution } \{X \mapsto cons(42, nil), Y \mapsto 42\} $.

We implemented a functional verifier which checks if a substitution equalizes two input terms. 
We represent a variable name as a unique Peano number. 
A substitution is represented as a list of terms, in which the index of the term is equal to the variable name to which the term is bound, so the substitution $\{X \mapsto cons(42, nil), Y \mapsto 42\}$ is represented as a list ``\lstinline{[cons(42, nil); 42]}''.
The verifier returns true if the input terms can be unified with the candidate substitution and false otherwise. 

As in the previous problem, we compare four solvers generated for the verifier described. 
With each solver, we search for a unifier of two terms and compare the execution times. 
The time comparison is presented in Table~\ref{tab:uni}. 
The first two rows of each column contain two terms being unified. 
We use uppercase letters from the end of the alphabet ($X, Y, \dots$) to denote variables, lowercase letters from the beginning of the alphabet ($a, b, \dots$) to denote constants (constructors with zero arguments), identifiers which start from the lowercase letter ($f, g,\dots$) to denote constructors.

Note, we compute a unifier for two terms, but not necessarily the most general unifier. 
We can implement the most general unification in \textsc{miniKanren}, but achieving the comparable performance using 
relational verifiers requires additional check that the unifier is indeed the most general. 
We are currently working on the implementation of such relational verifier. 

\begin{table}
\centering
\begin{tabular}{c|c|c|c}
\multirow{ 2}{*}{Terms} & 
f(X, a) & f(a \% b \% nil, c \% d \% nil, L) & f(X, X, g(Z, t))  \\
\cline{2-4} &
f(a, X) & f(X \% XS, YS, X \% ZS) & f(g(p, L), Y, Y)  \\
\hline\hline
Only conversion               & 0.01s  &  >300s & >300s \\
\hline
Backward oriented conversion  & 0.01s  &  0.11s & 2.26s  \\
\hline
Conversion and CPD            & 0.01s  &  0.07s & 0.90s  \\
\hline

Scheme interpreter            & 0.04s  & 5.15s & >300s    \\
\end{tabular}
 \caption{Searching for a unifier of two terms}
    \label{tab:uni}
\end{table}

Here four solvers compare to each other similarly to the previous problem: unnesting demonstrates the worst execution time, relational interpretation in Scheme is a little better, while unnesting aimed at backward execution and conjunctive partial deduction significantly improve the performance. 

There exist pairs of terms, for which either of the solvers fails to compute a unifier under 300 seconds. 
The example of such terms is ``\lstinline{f(A,B,C,A,B,C,D)}'' and ``\lstinline{f(B,C,D,x(R,S),x(a,T),x(Q,b),x(a,b))}''. 
This is caused by how general and declarative the verifier is: there is nothing in it to restrict the search space. 
We can modify the verifier with the additional check to ensure that there are no bound variables in the candidate unifier. 
This modification restricts the search space when there are many variables in the input terms.
But it also changes the semantics of the initial verifier and, as a consequence, the solvers: only idempotent unifiers can be found. 

To sum up, we demonstrated by two examples that it is possible to create problem solvers from verifiers by using relational conversion 
and conjunctive partial deduction. Currently conjunctive partial deduction improves the performance the most, as compared to 
interpreting verifiers with Scheme relational interpreter or doing relational conversion which is solely aimed at backward or 
forward execution.
