% !TeX spellcheck = ru_RU
% !TEX root = mainrus.tex

\section{Синтез расположения как задача удовлетворения ограничений}
\label{sec:guidelines}

%Закомменчено в аннлийской версии
%As we said earlier we are interested in a fully automatic approach to lay out GUI controls in a way prescribed
%by design guidelines. In this section we give a formal definition of what design guidelines are
%and how they define layouts, and specify the concrete problem of finding layouts which
%satisfy the constraints induced by both guidelines and the essence of layout primitives.

В нашей модели логическая структура, упомянутая в предыдущем разделе, описывается как набор отношений на некотором множестве элементов управления $\mathcal{C}$. Обозначим нашу структуру $\Sigma=\{r^{n_i}_i\, |\, r^{n_i}_i\subseteq\mathcal{C}^{n_i}\}$ как множество отношений, где    $r^{n_i}_i$ является \mbox{$n_i$-арным} отношением над $\mathcal{C}$;
без потери общности мы не будем рассматривать такие отношения, как размер, текстовое содержимое элементов управления и т.п.

%In our model given in the previous section the logical structure of GUI is described by
%a number of relations between a certain set of controls. Let $\mathcal{C}$ be a set of
%controls and let a structure $\Sigma=\{r^{n_i}_i\, |\, r^{n_i}_i\subseteq\mathcal{C}^{n_i}\}$ be a set of
%relations, where $r^{n_i}_i$ is an \mbox{$n_i$-ary} relation on $\mathcal{C}$; without loss
%of generality we do not consider property-like relations like size, text contents, etc.

\emph{Реляционным шаблоном} будем называть синтаксическую форму $r^n\,(X_1,\dots,X_n)$, где $r^n$ --- это $n$-арное отношение и $X_j$ --- это необязательно различные переменные.

%A \emph{relational pattern} is a syntactic form $r^n\,(X_1,\dots,X_n)$, where $r^n$ is $n$-ary
%relation and $X_j$ are variables (not necessarily distinct).

\emph{Шаблоном расположения} назовем синтаксическую форму $l\,(X_1,\dots,X_n)$, где $l$  --- это примитивы расположения, а $X_i$~--- переменные.

%A \emph{layout template} is a syntactic form $l\,(X_1,\dots,X_n)$, where $l$ is a layout primitive and
%$X_i$~--- variables.

Как $s\,[X_i\gets c_i]$ мы будем обозначать результат подстановки элементов управления
$c_i\in\mathcal{C}$
вместо переменных $X_i$ в реляционный шаблон или в шаблон расположения  $s$. Пусть $\mathcal{FV}\,(s)$~--- это множество всех переменных в реляционном шаблоне или в шаблоне расположения $s$, и будем называть \emph{экземпляром расположения} шаблон без переменных.

%We denote $s\,[X_i\gets c_i]$ the result of substitution of controls $c_i\in\mathcal{C}$
%for variables $X_i$ in a relational pattern or layout template $s$, $\mathcal{FV}\,(s)$~--- the set of all
%variables in a relational pattern or layout template $s$, and call \emph{layout instance} a layout
%template with no variables.


Пусть $r^n\,(X_1,\dots,X_n)$~--- это реляционный шаблон. Если для некоторого набора элементов управления $c_1,\dots,c_n\in\mathcal{C}$ верно %\footnote{\textcolor{red}{Где-то здесь Д.Кознов закричит про текст и нетекст.}}
$(c_1,\dots,c_n)\in r^n$, то будем говорить, что результат подстановки $r^n\,(X_1,\dots,X_n)\,[X_i\gets c_i]$
%Let $r^n\,(X_1,\dots,X_n)$ be a relational pattern. If for some controls $c_1,\dots,c_n\in\mathcal{C}$
%\[
%(c_1,\dots,c_n)\in r^n
%\]
%
%\noindent  то будем говорить, что результат подстановки
%\[
%r^n\,(X_1,\dots,X_n)\,[X_i\gets c_i]
%\]
%\noindent
\emph{встречается} в структуре $\Sigma$. %(Напоминаем, что $r^n$ --- это $n$-арное отношение над элементами управления).
%\textcolor{red}{Может можно как-то без напоминания??.}


\emph{Правило} (гайдлайна) будем записывать как
\[
p_1,\dots,p_k\mapsto l_1,\dots,l_m,
\]


\noindent  где $p_i$~--- реляционные шаблоны, $l_j$~--- шаблоны расположения.
Также потребуем, чтобы любая переменная в правой части хотя бы раз встречалась в левой. Неформально, правило говорит, что если некоторые элементы управления некоторым образом соотносятся в структуре, то  для них должны использоваться определенные примитивы расположения.

%We stipulate that any variable in the right-hand side of a
%rule has an occurrence in its left-hand side; no other restrictions are assumed. Informally a guideline rule says that if
%some controls are related in a certain manner in the structure then a specific layout primitives for (some of) these
%controls can be used.

Предположим, нам дана структура $\Sigma$ и множество экземпляров расположения $S$.
Будем говорить, что это множество \emph{подтверждается} набором правил
  \emph{R} тогда и только тогда, когда для каждого элемента управления $l^*\in S$


%Let us have a structure $\Sigma$ and a set $S$ of layout instances. We say that this set is \emph{confirmed} by a set of
%guideline rules \emph{R} iff for each control $l^*\in S$

\begin{enumerate}
\item существует правило $p_1,\dots,p_n\mapsto l_1,\dots,l_i,\dots, l_m$ в $R$, такое что
  $l^*=l_i\,[X_j\gets c_j]$  для некоторых
  $\{c_j\}\subseteq\mathcal{C}$, где $\mathcal{FV}\,(l_i)=\{X_j\}$;

\item для всех переменных $\{Y_1,\dots,Y_t\}=\mathcal{FV}\,(p_1,\dots,p_n)\setminus\mathcal{FV}\,(l_i)$ существуют элементы управления
$c^\prime_1,\dots,c^\prime_t\in\mathcal{C}$ такие, что для всех $j$ подстановка \mbox{$p_j\,[X_r\gets c_r,\dots,Y_s\gets c^\prime_s]$}
   встречается в структуре $\Sigma$;

\item \mbox{$l_j\,[X_r\gets c_r,\dots,Y_s\gets c^\prime_s]\in S$} для всех $j$.

\end{enumerate}

Неформально выражаясь, $R$ подтверждает множество $S$ тогда и только тогда, когда  все элементы управления $l^*$
могут быть корректно выведены из правил $R$. Это означает, что должно быть какое-то правило с шаблоном расположения $l_i$, который превратится в $l^*$ с помощью некоторой подстановки  переменных $X_i$. Но в этом правиле кроме $X_i$ могут быть другие переменные $Y_j$.
Если и для них существует такая подставка, которая совместно с подстановкой переменных $X_i$, заставит все реляционные шаблоны слева встречаться в  $\Sigma$,
тогда правило может быть применено и $l^*$ выведено. К тому же, в  правой части могут быть другие шаблоны расположения, и если и они окажутся тоже выведенными,
то этот экземпляр расположения должен быть добавлен в $S$.


%Informally speaking a set $S$ is confirmed by $R$ iff each its control $l^*$ can be properly
%derived according to $R$. This means that there should be some rule containing
%layout template $l_i$ which is turned into $l^*$ by some substitution of its
%variables $X_i$. However, in this rule there potentially can be other variables $Y_j$ besides $X_i$.
%If there exists a substitution for them which, together with the substitution for $X_i$, makes all
%relational patterns in the left-hand side to occur in $\Sigma$, then the rule can be
%applied and $l^*$ can be derived. Finally, as there can be other layout templates in the
%right-hand side of this rule, they will be derived as well, and thus corresponding
%layout instances have to be included in $S$.

Подтверждённые множества содержат в себе \emph{все} расположения, которые могут быть обоснованы правилами.
Эти множества не содержат лишних расположений. Однако подтверждённое расположение элементов управления не делает его автоматически \enquote{хорошим} с точки зрения дизайнера. Пустое множество всегда подтверждается, но едва ли его можно назвать   полезным расположением элементов. Из-за этого нам необходимо ввести ещё одно понятие: покрытие.

%Confirmed sets represent all layouts which can be justified according to the guidelines in the sense that they
%do not contain ``extra'' layout instances appeared out of thin air. However being confirmed does not
%necessarily mean to be a ``good'' layout in the sense a regular designer would imply. Indeed, an
%empty set is always confirmed, but can hardly be considered as a valuable layout. Thus, we define
%another property: \emph{coverage}.

Будем говорить, что экземпляры расположения $S$ \emph{покрывают} структуру $\Sigma$ \iffr{} для каждого элемента управления $c\in\mathcal{C}$
существует экземпляр расположения  в  $S$, который связывает $c$, т.е. содержит $c$ как параметр. Покрытие неформально обозначает, что  ни один элемент управления из структуры не остался не упомянутым в данном расположении.

%We say that a set of layout instances $S$ \emph{covers} a structure $\Sigma$ iff for each control $c\in\mathcal{C}$
%there is a layout instance in $S$ which binds $c$ (i.e. contains $c$ as a parameter). Coverage
%informally means that no control of a structure is left ``unaddressed'' by given layout.

Множество подтверждённых расположений в некотором смысле  соответствует всем \emph{корректным} расположениям с учетом правил,
а покрытие --- полноте. Однако мы воздержимся от введения этих понятий здесь, чтобы потом их употреблять в более общепринятом смысле.

%Confirmed sets in some sense correspond to \emph{sound} layouts w.r.t. to guidelines while covering~--- to
%\emph{complete}; however we refrain from calling them such since we reserve more conventional meanings of these terms.

Следующее требование навязано тем, что правила (гайдлайна) должны применяться, а не игнорироваться.
Будем называть подтвержденное и покрытое множество  $S$ \emph{максимальным} тогда и только тогда, когда не существует
подтвержденного и покрытого множества  $S^\prime$, что $S\subset S^\prime$.
%The next requirement comes from an observation that guideline rules are expected to be applied, not ignored. We
%call a confirmed and covering set of layout instances $S$ \emph{maximal} iff there is no
%confirmed and covering set $S^\prime$ such that $S\subset S^\prime$.

Наконец, расположения могут содержать конфликты. Например, если элемент $A$ должен быть расположен  сверху $B$ и наоборот,
то, очевидно, что мы получили несовместные ограничения. Среди всех конфликтов мы можем выделить следующие:

%Finally, layouts can contain conflicts. For example, if a layout says that a control $A$ has to be put on
%the top of control $B$ and visa versa then, obviously, it is unusable since these two primitives introduce
%incompatible constraints. Among the conflicts we can identify the following:

\begin{itemize}
\item Не должно быть циклов, составленных только из примитивов расположения для вертикальной (горизонтальной) композиции.
\item Не более одного элемента управления должно располагаться строго справа/снизу от другого элемента управления.
Это и предыдущее требование проистекает из того, что отношения, составленные из этих примитивов, должны быть линейными порядками.

\item Если два виртуальных элемента  управления расположены горизонтально,  то никакие два элемента управления внутри одного и  другого не должны располагаться вертикально. Аналогично для вертикально расположенных виртуальных элементов управления.
\item Никакие два элемента управления не могут быть расположены одновременно и вертикально, и горизонтально относительно друг друга.
\end{itemize}

%\begin{itemize}
%\item There should be no loops or branching comprised of layout primitives for vertical and horizontal composition. This
%  requirement originates from the observation that the relations introduced by these
%  primitives have to be unions of linear orders.
%\item If two compositional virtual controls are laid out horizontally then there should not be
%  controls within both of them which are laid out vertically; symmetrically for vertically
%  laid out virtual controls.
%\item No two controls can be laid out vertically and horizontally at the same time.
%\end{itemize}

Эти конфликты возникают из-за того, что мы располагаем элементы управления на двумерной плоскости (холсте).
Кроме них бывают и другие конфликты, которые мы опустили для краткости изложения.\footnote{\textcolor{red}{Может стоит дописать, если место будет?}}
Будем называть множества экземпляров без конфликтов \emph{совместными}.

%These conflicts originate from the fact that we actually place the controls on a two-dimensional plane.
%There are actually other cases which we omit here for space considerations. We call a set of
%instances \emph{compatible} iff it does not contain conflicts.

Итого, нам интересны подтвержденные, покрывающие структуру и совместные расположения с учетом выданного набора правил. Будем называть такие расположения \emph{корректными}.

%To summarize, we are interested in confirmed, covering, maximal and compatible layouts w.r.t. a given
%set of guideline rules. We call such layouts \emph{sound}.

Стоит обсудить вопрос производительности подхода в худшем случае. Легко заметить, что нахождение корректного расположения~--- в общем случае NP-полная задача.
Для подтверждения этого, рассмотрим решение NP-полной задачи поиска Гамильтонова пути в графе с помощью нашего подхода.
Для произвольного ненаправленного графа мы можем построить структуру, в которой один элемент управления соответствует одной вершине графа,  а некоторое бинарное отношение  ``$E$'' --- рёбрам. Затем рассмотрим такие правила расположения:

%It is worth mentioning the worst-case complexity of the problem in question. First, it is rather
%easy to see that finding if there exists a sound layout is $NP$-complete in general case.
%Indeed, given an undirected graph we can construct a structure where controls correspond to its nodes
%and some binary relation (call it ``$E$'') corresponds to edges. Then we take the following guideline:

\[
\begin{array}{rcl}
  E\,(x,\, y) & \mapsto & \mbox{hor}\,(x,\, y)\\
  E\,(x,\, y) & \mapsto & \mbox{hor}\,(y,\, x)
\end{array}
\]

Любое корректное расположение с учётом правил по определению содержит все элементы управления (т.е. узлы графа) и только примитивы расположения вида ``\texttt{hor}'', где каждое вхождение примитива соответствует одному ребру в графе. Так как примитивы не могут образовывать цикл, и каждый элемент управления может быть связан ребром только с одним другим элементом, то ребра образуют Гамильтонов путь.
%Any sound layout w.r.t. this guideline by definition contains all controls (i.e. nodes of the graph) and
%only layout primitives ``\texttt{hor}'', each of which corresponds to exactly one edge of the graph. Since
%``\texttt{hor}'' can not branch or loop, these edges form a Hamiltonian path.

С другой стороны, можно заметить, что количество всех корректных расположений в худшем случае экспоненциально зависит от размера структуры.
И выдача всех корректных расположений с помощью решателя, заставит его работать в худшем случае экспоненциально.
%On the other hand, it is rather easy to see that the number of all sound layouts can be worst-case
%exponential on the size of a structure. As we are aimed at enumerating them all the solvers for
%the problem would inevitably run in worst-case exponential time.


