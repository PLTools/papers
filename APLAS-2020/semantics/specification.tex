\section{Specification in \textsc{Coq}}
\label{specification}

We certified all the definitions and propositions from the previous sections using the \textsc{Coq} proof assistant.\footnote{The specification is available at \url{https://github.com/dboulytchev/miniKanren-coq}} The \textsc{Coq} specification for the most part closely follows the formal descriptions we gave by means of inductive definitions (and inductively defined propositions in particular) and structural induction in proofs. The detailed description of the specification, including code snippets, is provided in the extended version of the paper, and in this section we address only some non-trivial parts of it and some design choices.

The language formalized in \textsc{Coq} has a few non-essential simplifications for the sake of convenience. Specifically, we restrict the arities of all constructors to be either zero or two and require all relations to have exactly one argument. These restrictions do not make the language less expressive in any way since we can always represent a sequence of terms as a list using constructors \lstinline|Nil$^0$| and \lstinline|Cons$^2$|. 

In our formalization of the language we use higher-order abstract syntax~\cite{HOAS} for variable binding, therefore we work explicitly only with semantic variables. We preferred it to the first-order syntax because it gives us the ability to use substitution and the induction principle provided by \textsc{Coq}. On the other hand, we need to explicitly specify a requirement on the syntax representation, which is trivially fulfilled in the first-order case: all bindings have to be ``consistent'', i.e. if we instantiate a higher-order \lstinline|fresh| construct with different semantic variables the results will be the same up to some renaming (provided that both those variables are not free in the body of the binder). Another requirement we have to specify explicitly (independent of HOAS/FOAS dichotomy) is a requirement that the definitions of relations do not contain unbound semantic variables.

To formalize the operational semantics in \textsc{Coq} we first need to define all preliminary notions from unification theory~\cite{Unification} which our semantics uses. In particular, we need to implement the notion of the most general unifier (MGU). As it is well-known~\cite{StructuralMGU} all standard recursive algorithms for calculating MGU are not decreasing on argument terms, so we can't define them as simple recursive functions in \textsc{Coq} due to the termination check failure. The standard approach to tackle this problem is to define the function through well-founded recursion. We use a distinctive version of this approach, which is more convenient for our purposes: we define MGU as a proposition (for which there is no termination requirement in \textsc{Coq}) with a dedicated structurally-recursive function for one step of unification, and then we use a well-founded induction to prove the existence of a corresponding result for any arguments and defining properties of MGU. For this well-founded induction, we use the number of distinct free variables in argument terms as a well-founded order on pairs of terms.

In the operational semantics, to define traces as (possibly) infinite sequences of transitions we use the standard approach in \textsc{Coq}~--- coinductively defined streams. Operating with them requires a number of well-known tricks, described by Chlipala~\cite{CPDT}, to be applied, such as the use of a separate coinductive definition of equality on streams.

The final proofs of soundness and completeness of operational semantics are relatively small, but the large amount of work is hidden in the proofs of auxiliary facts that they use (including lemmas from the previous sections and some technical machinery for handling representing functions).
