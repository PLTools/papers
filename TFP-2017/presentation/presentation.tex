\documentclass{beamer}

\usepackage{amssymb, amsmath}
%\usepackage[all]{xy}

\usepackage{alltt}
\usepackage{pslatex}
\usepackage{epigraph}
\usepackage{verbatim}

%\usepackage{graphicx}
\usepackage{latexsym}
\usepackage{array}
\usepackage{comment}
\usepackage{makeidx}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{color}
\usepackage{url}
\usepackage{xspace}
%\usepackage{fontspec}
%\usepackage{xunicode}
%\usepackage{xltxtra}
%\usepackage{xecyr}
\usepackage{hyperref}
%\usepackage[english]{babel}
%\usepackage[utf8]{inputenc}
%\setmainfont[Mapping=tex-text]{DejaVu Serif}
%\setsansfont[Mapping=tex-text]{DejaVu Sans}
%\setmonofont[Mapping=tex-text]{DejaVu Sans Mono}
%\usepackage{polyglossia}
%\setdefaultlanguage{russian}
\usepackage{stmaryrd}

\usepackage{amsmath, amsthm, amssymb}
\usepackage{graphicx}
\usepackage{euscript}
\usepackage{mathtools}

\makeatletter
\begin{comment}
\newcolumntype{e}[1]{%--- Enumerated cells ---
   >{\minipage[t]{\linewidth}%
     \NoHyper%                Hyperref adds a vertical space
     \let\\\tabularnewline
     \enumerate
        \addtolength{\rightskip}{0pt plus 50pt}% for raggedright
        \setlength{\itemsep}{-\parsep}}%
   p{#1}%
   <{\@finalstrut\@arstrutbox\endenumerate
     \endNoHyper
     \endminipage}}

\newcolumntype{i}[1]{%--- Itemized cells ---
   >{\minipage[t]{\linewidth}%
        \let\\\tabularnewline
        \itemize
           \addtolength{\rightskip}{0pt plus 50pt}%
           \setlength{\itemsep}{-\parsep}}%
   p{#1}%
   <{\@finalstrut\@arstrutbox\enditemize\endminipage}}

\AtBeginDocument{%
    \@ifpackageloaded{hyperref}{}%
        {\let\NoHyper\relax\let\endNoHyper\relax}}
\end{comment}

\makeatother

\definecolor{shadecolor}{gray}{1.00}
\definecolor{darkgray}{gray}{0.30}

\newcommand{\set}[1]{\{#1\}}
\newcommand{\angled}[1]{\langle {#1} \rangle}
\newcommand{\fib}{\rightarrow_{\mathit{fib}}}
\newcommand{\fibm}{\Rightarrow_{\mathit{fib}}}
\newcommand{\oo}[1]{{#1}^o}
\newcommand{\inml}[1]{\mbox{\lstinline{#1}}}
\newcommand{\goal}{\mathfrak G}
\newcommand{\inmath}[1]{\mbox{$#1$}}
\newcommand{\sembr}[1]{\llbracket{#1}\rrbracket}

\newcommand{\withenv}[2]{{#1}\vdash{#2}}
\newcommand{\ruleno}[1]{\eqno[\textsc{#1}]}
\newcommand{\trule}[2]{\dfrac{#1}{#2}}

%\setlength{\epigraphwidth}{.55\textwidth}

\definecolor{light-gray}{gray}{0.90}
\newcommand{\graybox}[1]{\colorbox{light-gray}{#1}}

\newcommand{\nredrule}[3]{
  \begin{array}{cl}
    \textsf{[{#1}]}& 
    \begin{array}{c}
      #2 \\
      \hline
      \raisebox{-1pt}{\ensuremath{#3}}
    \end{array}
  \end{array}}

\newcommand{\naxiom}[2]{
  \begin{array}{cl}
    \textsf{[{#1}]} & \raisebox{-1pt}{\ensuremath{#2}}
  \end{array}}

\lstdefinelanguage{ocaml}{
keywords={let, begin, end, in, match, type, and, fun, 
function, try, with, class, object, method, of, rec, repeat, until,
while, not, do, done, as, val, inherit, module, sig, @type, struct, 
if, then, else, open, virtual, new, fresh},
sensitive=true,
basicstyle=\small,
commentstyle=\scriptsize\rmfamily,
keywordstyle=\ttfamily\bfseries,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={fun}{{$\lambda$}}1 {->}{{$\to$}}3 {===}{{$\equiv$}}1 {=/=}{{$\not\equiv$}}1 {|>}{{$\triangleright$}}3 {\&\&\&}{{$\wedge$}}2 {|||}{{$\vee$}}2 {^}{{$\uparrow$}}1,
morecomment=[s]{(*}{*)}
}

\lstset{
mathescape=true,
basicstyle=\small,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
escapechar=!,
language=ocaml
}

\begin{comment}
\lstdefinelanguage{ocaml}{
keywords={fresh, let, begin, end, in, match, type, and, fun, function, try, with, when, class,
object, method, of, rec, repeat, until, while, not, do, done, as, val, inherit,
new, module, sig, deriving, datatype, struct, if, then, else, open, private, virtual, include, @type},
sensitive=true,
commentstyle=\small\itshape\ttfamily,
keywordstyle=\ttfamily\underbar,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,

literate={->}{{$\to\;\;$}}3 {===}{{$\equiv$}}3 {=/=}{{$\not\equiv$}}3 {|>}{{$\triangleright$}}3,
morecomment=[s]{(*}{*)}
}

\lstset{
mathescape=true,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
language=ocaml
}
\end{comment}
\sloppy

\newcommand{\miniKanren}{\texttt{miniKanren}\xspace}
\newcommand{\ocanren}{\texttt{OCanren}\xspace}
\newcommand{\ocaml}{\texttt{OCaml}\xspace}

\setbeamertemplate{footline}[frame number]
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{blocks}[rounded][shadow=true] 
\beamertemplateballitem

\mode<presentation>{
  \usetheme{default}
}

\theoremstyle{definition}

\title{Typed Relational Conversion}

\author{
  \underline{Petr Lozov} \and Andrei Vyatkin \and Dmitry Boulytchev
}

\institute[]{
\small{
\textbf{Saint Petersburg State University $\: $\\JetBrains Research}
}
}

\date{
   \vskip 1cm
   \small{
   \textbf{The Symposium on Trends in Functional Programming}\\
   May 20, 2017 \\
   University of Kent, Canterbury}
}

\begin{document}
\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}{Relational Programming}

    \begin{itemize}
      \item[] From programs as \emph{functions} to programs as \emph{relations}:
      $$
        f : A\to B\;\; \leadsto \;\;f^o \subseteq A \times B
      $$
      \vskip-2mm
      \pause
      \item[] No difference between arguments and the result.
      \pause
      \vskip4mm
      \item[] \miniKanren:
        \begin{itemize} 
           \item[-] Daniel P. Friedman, William Byrd, Oleg Kiselyov. \emph{The Reasoned Schemer}, 2005;
           \item[-] minimalistic DSL for Scheme/Racket; 
           \item[-] a family of languages ($\mu$Kanren, $\alpha$-Kanren, cKanren, etc.);
           \item[-] implemented as a DSL for a wide range of host languages (OCaml, Haskell, Scala).
        \end{itemize}   
    \end{itemize}


\end{frame}

\begin{frame}[fragile]{\ocanren (Typed Version for \ocaml)}

Syntactic forms of goals:
\begin{itemize}
  \item[-] unification $t_1\;\equiv\;t_2$;
  \item[-] disequality constraint $t_1\;\not\equiv\;t_2$;
  \item[-] conjunction $g_1\wedge g_2$;
  \item[-] disjunction $g_1\vee g_2$;
  \item[-] fresh variable introduction \lstinline{fresh ($x$) $\;g$}.
\end{itemize}

\pause
\vskip5mm
Any goal has type $\goal$.

\end{frame}

\begin{frame}[fragile]{\ocaml \emph{vs.} \ocanren}
\centering
\begin{tabular}{c}
 \begin{lstlisting}
type nat = O | S of nat
 \end{lstlisting} \pause \\[5mm]
\end{tabular}
 
\begin{tabular}[b]{c p{1mm} c}
 \begin{lstlisting}[mathescape=true,language=ocaml]
val add : nat->nat->nat

let rec add x y = 
  match x with
  | O    -> y
  | S x' -> S (add x' y)!\pause!
  
  
  $ $
 \end{lstlisting} & &
 \begin{lstlisting}[mathescape=true,language=ocaml]
val add$^o$ : nat->nat->nat->$\goal$

let rec add$^o$ x y z!\pause! = 
  (x === O &&& y === z)!\pause! |||
  (fresh (x' z')!\pause! (
     (x === S x')!\pause! &&&
     (z === S z')!\pause! &&&
     (add$^o$ x' y z')    
  ))
 \end{lstlisting}
\end{tabular}

\end{frame}

\begin{frame}[fragile]{\ocanren Execution}
\begin{center}
\begin{tabular}{l}
 \begin{lstlisting}[mathescape=true,language=ocaml]
val add$^o$ : nat->nat->nat->$\goal$

let rec add$^o$ x y z = 
  (x === O &&& y === z) |||
  (fresh (x' z') (
     (x === S x') &&&
     (z === S z') &&&
     (add$^o$ x' y z')    
  ))
 \end{lstlisting}
 \end{tabular}
 \end{center}

\pause
\vskip3mm

\begin{center}
\begin{tabular}{ccc}
Query & & Stream \\
\hline
  \begin{lstlisting}
add$^o$ '3' '4' $\;\;q\;\;$
  \end{lstlisting} &
$\leadsto$ &
  \begin{lstlisting}
[$q$ = '7']
  \end{lstlisting} \pause\\
\hline
  \begin{lstlisting}
add$^o$ $\;\;q\;\;$ '4' '7'
  \end{lstlisting} &
$\leadsto$ & 
  \begin{lstlisting}
[$q$ = '3']
  \end{lstlisting} \pause\\
\hline
  \begin{lstlisting}
add$^o$ $\;\;q\;\;$ $\;\;r\;\;$ '2'
  \end{lstlisting} &
  $\leadsto$ &
  \begin{lstlisting}
[$q$ = '0', $r$ = '2';
 $q$ = '1', $r$ = '1';
 $q$ = '2', $r$ = '0']
  \end{lstlisting}
\end{tabular}
\end{center}
\end{frame}

\begin{frame}[fragile]{``The Promise of Relational Programming''}
\begin{itemize}
    \item[-] Relational type inferencer for STLC as inhabitation problem solver (Byrd, 2009).  
    \vskip5mm
    \item[-] Relational interpreter as ``quine'' generator (Byrd \emph{et al}, 2015).
    \vskip5mm
    \item[-] Relational list sorting as generator of all permutations (Kosarev \emph{et al}, 2016).
\end{itemize}

\begin{comment}
\begin{itemize}
    \item Greater flexibility in comparison with functions
    \item Writing relations is more tedious
    \item Many relations can be written by regular "generalizing" a certain functional program
\end{itemize}
\end{comment}

\end{frame}

\begin{frame}[fragile]{Example: Type Inference for STLC}

\begin{tabular}{cc|l}
 & & 
 \begin{lstlisting}
let rec infer$^o$ exp env typ=
 \end{lstlisting}\\
 $\withenv{\Gamma}{x:\Gamma\;x}$ &
 [Var] &
 \begin{lstlisting}
  (fresh (x) (
    (exp === Var x) &&& 
    (lookapo$^o$ x env typ)
 \end{lstlisting} \\ 
 & &
 \begin{lstlisting}
  )) |||
 \end{lstlisting} \\
 $\trule{\withenv{\Gamma, x:\tau}{M:\rho}}
      {\withenv{\Gamma}{\lambda x.M:\tau\to\rho}}$ &
 [Abstr] &
 \begin{lstlisting}
  (fresh (x b t) (
    (exp === Abstr(x,b)) &&&
    (infer$^o$ b ((x,t):env) typ)
 \end{lstlisting}\\ 
 & &
 \begin{lstlisting}
  )) |||
 \end{lstlisting} \\
 $\trule{\withenv{\Gamma}{M:\tau\to\rho},\withenv{\Gamma}{N:\tau}}
      {\withenv{\Gamma}{M\;N:\rho}}$ &
 [App] &
 \begin{lstlisting}
  (fresh (a b t) (
    (exp === App(a, b)) &&&
    (infer$^o$ a env(Arr(t,typ))) &&&
    (infer$^o$ b env t)
  ))
 \end{lstlisting}
\end{tabular}
\end{frame}

\begin{frame}[fragile]{``Essential'' vs. ``Non-essential'' Relational Programs}
\begin{itemize}
    \item[] ``Essential'' relational program:
    \begin{itemize}
        \item[-] naturally expressed in relational terms;
        \item[-] example: relational type inference for STLC.
    \end{itemize} 
    \pause \vskip5mm
    \item[] ``Non-essential'' relational program:
    \begin{enumerate}
        \item[-] mimics existing functional program;
        \item[-] example: relational interpreter of Scheme;
        \pause        
        \item[-] \color{green}{can be automated.}
    \end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Unnesting}
\begin{itemize}
    \item[-] Converts a function to a relation.
    \item[-] Described informally (Friedman \emph{et al}, 2009).
    \pause\vskip5mm
    \item[-] The main idea:
    \begin{itemize}
        \item[-] bind nested function calls to fresh names;
        \item[-] add an additional argument and unify the result with it;
        \item[-] convert pattern matching into the disjunction of cases.
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Unnesting: Example}
  \begin{tabular}{ccc}
    \begin{lstlisting}
let rec append a b =
  match a with
  | Nil        -> b
  | Cons(x,xs) -> 
    Cons(x, append xs b)
    $ $
    \end{lstlisting} & 
    $\Rightarrow$ &
    \begin{lstlisting}
let rec append a b =
  match a with
  | Nil        -> b
  | Cons(x,xs) -> 
    let xs' = append xs b in
    Cons(x,xs')              
    \end{lstlisting}
  \end{tabular}
\end{frame}

\begin{frame}[fragile]{Unnesting: Example}
  \begin{tabular}{ccc}
    \begin{lstlisting}
let rec append a b =
  match a with
  | Nil        -> b
  | Cons(x,xs) -> 
    let xs' = append xs b in
    Cons(x,xs')       
    $ $
    \end{lstlisting} &
    $\Rightarrow$ &
    \begin{lstlisting}
let rec append$^o$ a b c =
  (a === Nil) &&& (b === c) |||
  (fresh (x xs xs') (
    (a === Cons(x,xs))
    (c === Cons(x,xs'))
    (append$^o$ xs y xs')
  ))
    \end{lstlisting}
  \end{tabular}
\end{frame}

\begin{frame}[fragile]{From Unnesting to Typed Relational Conversion}
Unnesting:
\begin{itemize}
    \item[-] no formal description or implementation;
    \item[-] untyped;
    \item[-] does not work for partial applications.
\end{itemize}
\vskip5mm
\pause
Typed Relational Conversion:
\begin{itemize}
    \item[-] in typed case;
    \item[-] for higher-order functions as well.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Core Functional Language}
\begin{tabular}{rcll}
  $\mathcal E$ &=&$x$                                                               &(variable)\\
               & &$\lambda x.e$                                                     &(abstraction)\\
               & &$e_1\;e_2$                                                        &(application)\\ 
               & &$C^n(e_1,\dots, e_n)$                                             &(constructor application)\\
               & &\lstinline|let $x$ = $e_1$ in $e_2$|                              &(let-binding)\\
               & &\lstinline|let rec $f$ = $\lambda x.e_1$ in $e_2$|                &(recursive let-binding)\\
               & &$e_1\,=\,e_2$                                                     &(equality test)\\
               & &\lstinline|match $e$ with {$p_i$ -> $e_i$}|                     &(pattern matching)
\end{tabular}

\end{frame}

\begin{frame}[fragile]{Relational Extension}
\begin{tabular}{rcll}
  $\mathcal E$ & $+=$ &\lstinline|fresh ($x$) $\;e$| &(fresh logical variable binder) \\
               &           &$e_1\equiv e_2$               & (unification)                   \\
               &           &$e_1\not\equiv e_2$           & (disequality constraint)        \\
               &           &$e_1\vee e_2$                 & (disjunction)                   \\
               &           &$e_1\wedge e_2$               & (conjunction)

\end{tabular}
\end{frame}

\begin{frame}[fragile]{Syntactic Unification Restriction}

 \begin{center}
 Syntactic unification works for first-order terms only:
 \pause\vskip5mm
  \begin{tabular}{m{0.4\linewidth}m{0.4\linewidth}}
   \begin{lstlisting}
let unbox cf =
  match cf with
  | C f $\rightarrow$ f !\pause!
   \end{lstlisting} &
   \begin{lstlisting}
let unbox$^o$ cf res =
  fresh (f) (
    (cf === C f) |||
    (f === res))
   \end{lstlisting}
  \end{tabular}
 \pause \vskip5mm
 $\Rightarrow$ constructors cannot bind functions 
 \end{center}
%  \begin{itemize} 
%     \item Hindley-Milner type system
%     \item Constraint of constructor types
%     \item Constraint of polymorphism
% \end{itemize}
\end{frame}

\begin{frame}[fragile]{Typing: Fully-polymorphic Types}

\begin{center}
Each constructor binds only type variables:

\vskip5mm

\begin{tabular}{c}
\begin{lstlisting}
type ($\alpha$, $\beta$) alist =
  | Nil
  | Cons of $\alpha$ * $\beta$

type $\alpha$ list = ($\alpha$, $\alpha$ list) alist
\end{lstlisting}
\end{tabular}
\end{center}
\end{frame}

\begin{frame}[fragile]{Typing: Bounded Polymorphism}
\begin{center}
``Good'' types:
\vskip2mm
$$
\begin{array}{rcll}
  \mathcal G &\mathrel{{=}}&a                        &\mbox{(primitive types)}\\ 
             &             &\alpha                   &\mbox{{(type variables)}}                   \\
             &             & (g_1, ..., g_n) \; t_c   &\mbox{{(application of type constructors)}} \\
\end{array}
$$

\vskip1cm
Only applications to ``good'' types allowed
\end{center}

\end{frame}

\begin{frame}\frametitle{Type Conversion}
$$
\begin{array}{rcl}
\sembr{g}                     & = & g \to \goal \\
\sembr{\forall \alpha. \: t} & = & \forall \alpha. \: \sembr{t} \\
\sembr{t_1 \to t_2}  & = & \sembr{t_1} \to \sembr{t_2} \\
\end{array}
$$
\vskip2mm
\pause
\begin{center}
Example:
\end{center}
$$
\begin{array}{rcl}
\inmath{\sembr{int}}           & = & \inmath{int} \to \goal \\
\inmath{\sembr{string\to int}} & = & (\inmath{string} \to \goal) \to (\inmath{int} \to \goal)
\end{array}
$$
\end{frame}

\begin{frame}[fragile]{Term Conversion: Lambda Part}

\begin{tabular}{rclr}
  \begin{lstlisting}
$\llbracket$x$\rrbracket$
  \end{lstlisting} &
  $\leadsto$ &
  \begin{lstlisting}
x
  \end{lstlisting} &
  [Var] \\
  \begin{lstlisting}
$\llbracket$fun x -> $A\rrbracket$  
  \end{lstlisting} &
  $\leadsto$ &
  \begin{lstlisting}
fun x -> $\llbracket A\rrbracket$
  \end{lstlisting} &
  [Abst] \\
  \begin{lstlisting}
$\llbracket A \; B\rrbracket$  
  \end{lstlisting} &
  $\leadsto$ &
  \begin{lstlisting}
$\llbracket A\rrbracket \; \llbracket B\rrbracket$
  \end{lstlisting} &
  [App] \\
\begin{lstlisting}
$\llbracket$let x = $A$ in $B\rrbracket$  
  \end{lstlisting} &
  $\leadsto$ &
  \begin{lstlisting}
let x = $\llbracket A\rrbracket$ in $\llbracket B\rrbracket$
  \end{lstlisting} &
  [Let] \\
  \begin{lstlisting}
$\llbracket$let rec x = $A$ in $B\rrbracket$  
  \end{lstlisting} &
  $\leadsto$ &
  \begin{lstlisting}
let rec x = $\llbracket A\rrbracket$ in $\llbracket B\rrbracket$
  \end{lstlisting} &
  [LetRec] \\
\end{tabular}

 \vskip1cm
 \begin{center}
   (terms do not change much) %, but types do)
 \end{center}

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}[fragile]{Term Conversion: Constructors}
\centering
\begin{tabular}{rcl}
  \begin{lstlisting}
$\llbracket$Nil$\rrbracket$
  \end{lstlisting} & 
  $\leadsto$ & 
  \begin{lstlisting}
(=== Nil)
  \end{lstlisting} \\
&\\
  \begin{lstlisting}
$\llbracket$Cons $A$ $B\rrbracket$
  \end{lstlisting} & 
  $\leadsto$ & 
  \begin{lstlisting}
fun r -> 
  fresh (p q) 
    ($\sembr{A}$ p) &&& 
    ($\sembr{B}$ q) &&& 
    (r ===$\;$Cons p q)
  \end{lstlisting}
\end{tabular}

\begin{comment}
Left-to-right
    \begin{center}
    \begin{tabular}{c|c}
          
      \begin{lstlisting}[mathescape=true,language=ocaml]
Cnst$_{Nil}$
      \end{lstlisting} &

      \begin{lstlisting}[mathescape=true,language=ocaml]
Cnst$_{Cons}$     
      \end{lstlisting} \\
      \hline
      \rule{0cm}{1cm}
      \begin{lstlisting}[mathescape=true,language=ocaml]
Nil
      \end{lstlisting} &

      \begin{lstlisting}[mathescape=true,language=ocaml]
Cons (f x) (map f xs)     
      \end{lstlisting} \\[5mm]
      \hline
      \begin{lstlisting}[mathescape=true,language=ocaml]
 $\lambda$ res. res $\equiv$ Nil
      \end{lstlisting} &
      \begin{lstlisting}[mathescape=true,language=ocaml]
 
 fun r ->
   fresh ($p$ $q$) (
     (f x $p$) &&&
     (map f xs $q$) &&&
     (r === Cons $p$ $q$))
      \end{lstlisting}
    \end{tabular}
    \end{center}
\end{comment}

\end{frame}

\begin{frame}[fragile]{Term Conversion: Pattern Matching}
  \begin{tabular}{rcl}
    \scalebox{3.5}{$\llbracket$}
    \begin{lstlisting}
match $A$ with
| Nil       $\rightarrow$ $B$
| Cons x xs $\rightarrow$ $C$
$$

    \end{lstlisting}
    \scalebox{3.5}{$\rrbracket$}
&
    $\leadsto$ & 
    \begin{lstlisting}
fun r.
 fresh (a) (
  ($\llbracket A\rrbracket$ a) &&& (
   ((a === Nil) &&& ($\llbracket B\rrbracket$ r)) ||| 
   (fresh (x' xs') (
    (a === Cons(x',xs'))
    ((fun x xs q -> $\llbracket C\rrbracket$) 
      (=== x') (=== xs') r))
 ))))
    \end{lstlisting}
    \end{tabular}
\end{frame}

%-------------------------------------------------------------------------------

\begin{comment}
\begin{frame}[fragile]\frametitle{Term Conversion: Pattern Matching}

    \begin{tabular}{l}
    \rule{0cm}{5mm}
    \begin{lstlisting}[mathescape=true,language=ocaml]
match l with
| Nil       $\rightarrow$ Nil
| Cons x xs $\rightarrow$ Cons (f x) (map f xs)


$\lambda$ res.
  fresh (res$_l$) (
    (l res$_l$) $\wedge$ (
      ((res$_l$ $\equiv$ Nil) $\wedge$ (Cnst$_{Nil}$ res)) $\vee$ 
      (fresh (res$_x$ res$_{xs}$) (
        (res$_l$ $\equiv$ Cons res$_x$ res$_{xs}$) $\wedge$
        (($\lambda$x. $\lambda$xs. Cnst$_{Cons}$) (($\equiv$) res$_x$) (($\equiv$) res$_{xs}$) res)))))
    \end{lstlisting}
    \end{tabular}
\end{frame}
\end{comment}
%-------------------------------------------------------------------------------
\begin{frame}[fragile]{Term Conversion: Example}
    \begin{center}
    \begin{tabular}{l}
    \begin{lstlisting}[mathescape=true,language=ocaml]
map :: ($\alpha$ $\rightarrow$ $\beta$) $\rightarrow$ $\alpha$ list $\rightarrow$ $\beta$ list

let rec map f l =
  match l with
  | Nil       $\rightarrow$ Nil 
  | Cons x xs $\rightarrow$ Cons (f x) (map f xs)    
    \end{lstlisting}
    \end{tabular}
    \end{center}
\end{frame}

\begin{comment}
\begin{frame}[fragile]{Term Conversion: Example}
    \begin{center}    
    \begin{tabular}{l}
    \begin{lstlisting}[mathescape=true,language=ocaml]
map$^o$ :: (($\alpha$ $\to$ $\goal$) $\rightarrow$ $\beta$ $\to$ $\goal$) $\rightarrow$ ($\alpha$ list $\to$ $\goal$) $\rightarrow$ $\beta$ list $\to$ $\goal$    
    
let rec map$^o$ f l r =
  fresh (l') (
    (l l') &&&
    ((l' === Nil) &&& ((=== Nil) r)) |||
    (fresh (x' xs')
      (l' === Cons (x', xs')) &&&
      (funx xs q -> 
        (fresh (a b)
          (f x a) &&&
          (map$^o$ f xs b) &&&
          (q === Cons (a, b))))
      (=== x') (=== xs') r))
     
    \end{lstlisting}
    \end{tabular}
    \end{center}
\end{frame}
\end{comment}

\begin{frame}[fragile]{Term Conversion: Example}
    \begin{center}
    \begin{tabular}{l}
    \begin{lstlisting}[mathescape=true,language=ocaml]
map$^o$ :: (($\alpha$ $\to$ $\goal$) $\rightarrow$ $\beta$ $\to$ $\goal$) $\rightarrow$ ($\alpha$ list $\to$ $\goal$) $\rightarrow$ $\beta$ list $\to$ $\goal$    
    
let rec map$^o$ f l r =
  fresh (l') (
    (l l') &&&
    ((l' === Nil) &&& (r === Nil)) |||
    (fresh (x' xs')
      (l' === Cons (x', xs')) &&&   
        (fresh (a b)
          (f (=== x') a) &&&
          (map$^o$ f (=== xs') b) &&&
          (r === Cons (a, b)))
    ))
     
    \end{lstlisting}
    \end{tabular}
    \end{center}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}[fragile]{Typed Conversion: Correctness}
\centering
\begin{itemize}
    \item[-] The standard semantics for functional core was rewritten in the form of transition system (``$\to$'');
    \item[-] This semantics was extended for the relational super-language (becoming non-deterministic) (``$\leadsto$'');
    \item[-] Typing was extended for relational super-language as well.
\end{itemize}
\pause
{\bf Typing correctness:}
$$
\forall P:t\Rightarrow\sembr{P}:\sembr{t}
$$
\pause
{\bf Semantic correctness (in progress):}
$$
\forall P:g, P\to^* v\Rightarrow\mbox{\lstinline|fresh (q) ($\sembr{P}\;$ q) $\;\leadsto^*\;$ [q=$v$]|}
$$

\end{frame}

\begin{comment}
\begin{frame}[fragile]{Static Correctness}
Let
\begin{itemize}
    \item[-] $P$~--- typed functional program
    \item[-] $P^o$--- converted typed relational program
\end{itemize}  
\vskip0.2cm
If $P:t$, then $P^o:\sembr{t}$ (up to renaming type variables)
\end{frame}

\begin{frame}[fragile]{Dynamic Correctness}
Let
\begin{itemize}
    \item[-] $P$ -- functional program
    \begin{itemize}
        \item[] with type $t_1 \to \ldots \to t_n \to g$,
        \item[] where g - non-functional type;
    \end{itemize}
    \item[-] $P_{rel}$ -- relational program resulting from a conversion $P$
    \begin{itemize}
        \item[] with type $\sembr{t_1} \to \ldots \to \sembr{t_n} \to g \to \goal$.
    \end{itemize}
\end{itemize}  
\vskip0.2cm
$\forall \; a_1,\dots, a_n, b$ with types $t_1, ..., t_n, g$ such that if $P \; a_1 \dots a_n = b$ 
\linebreak then $P_{rel} \; \sembr{a_1} \ldots \sembr{a_n} \; \sembr{b}$ is success goal.

\vskip5mm
This statement will be proved.
\end{frame}
\end{comment}
%-------------------------------------------------------------------------------

\begin{comment}
\begin{frame}\frametitle{Implementation}

\begin{itemize}
    \item Input language -- subset of OCaml
    \item Output language -- OCanren
    \item Language of implementation -- OCaml
\end{itemize}

\end{frame}
\end{comment}

%-------------------------------------------------------------------------------

\begin{frame}[fragile]{Evaluation: Benchmarks}

\begin{itemize}
    \item[-] Lambda Calculus Interpreter:
    \begin{itemize}
        \item[-] ``Non-essential'' problem;
        \item[-] Relational interpreters~--- one of the main applications.
    \end{itemize}
    \pause\vskip2mm
    \item[-] Type inference for Hindley-Milner type system:
        \begin{itemize}
        \item[-] Tricky, if considered as ``essential'' problem;
        \item[-] Did not have relational implementation for a long time.
    \end{itemize}
    \pause\vskip2mm
    \item[-] \miniKanren with Disequality Constraints
        \begin{itemize}
        \item[-] ``Non-essential'' problem;
        \item[-] Quite laborious;
        \item[-] Implemented for the first time.
    \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}[fragile]\frametitle{Evaluation: Lambda Interpreter}
  \begin{itemize}
      \item[-] Lambda Calculus in De Bruijn notation;
      \vskip5mm
      \pause
      \item[-] Interpreter --- a higher-order function, parameterized by
               reduction strategy:
  \begin{lstlisting}
       val eval : term -> (term -> split) -> term
  \end{lstlisting}
  \pause
      \item[-] Reduction strategies:
  \begin{lstlisting}
       val call_by_name  : term -> split
       val call_by_value : term -> split
       val normal_order  : term -> split
  \end{lstlisting}
\end{itemize}
  
\end{frame}

\begin{frame}[fragile]{Evaluation: Lambda Interpreter}
\begin{tabular}{l}
\begin{lstlisting}[]
eval$^o$ normal_order$^o$ (=== '(fun 0) 1') q $\leadsto^*$
  [q = '1']
   
eval$^o$ call_by_name$^o$ (=== '0 ((fun 0) 1)') q $\leadsto^*$
  [q = '0 ((fun 0) 1)']   

eval$^o$ call_by_value$^o$ (=== '0 ((fun 0) 1)') q $\leadsto^*$
  [q = '0 1'] 
\end{lstlisting}
\end{tabular}

\end{frame}

\begin{frame}[fragile]{Evaluation: Lambda Interpreter}
\begin{lstlisting}
eval$^o$ normal_order$^o$ (=== q) ('fun 0') $\leadsto^*$ 
  [
    q = 'fun 0'; 
    q = '(fun 0) (fun 0)'; 
    q = 'fun ((fun 1) $\framebox{0}$)'; 
    q = '(fun 0) ((fun 0) (fun 0))';  
    ...
  ] 

eval$^o$ call_by_name$^o$ (=== q) ('fun 0') $\leadsto^*$ 
  [
    q = 'fun 0'; 
    q = '(fun 0) (fun 0)'; 
    q = '(fun 0) ((fun 0) (fun 0))'; 
    q = '(fun fun 0) 0'; 
    ...
  ] 
\end{lstlisting}
     
\end{frame}

%-------------------------------------------------------------------------------
\begin{comment}

\begin{frame}[fragile]\frametitle{Evaluation: Syntactic Unification}
\begin{tabular}{l}
\begin{lstlisting}
unify (=== Var "x") (=== (Cnst ("A", (=== [])))) [] q 
==> [q = Some [("x", Cnst ("A", []))]]
   
   
   
unify (=== q) (=== (Cnst ("A", []))) (=== []) 
      (Some [("z", (Cnst ("A", [])))])) 
==>  [q = Var "z"]     
\end{lstlisting}
\end{tabular}

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}[fragile]\frametitle{Evaluation: Syntactic Unification}

\begin{tabular}{l}
\begin{lstlisting}
unify (=== q) (=== r) (=== []) 
      (Some [("z", (Cnst ("A", [])))]) 
==> [(
      q = Var "x", 
      r = Cnst ("A", [])
    ); (
      q = Cnst ("A", []), 
      r = Var "x"
    ); (
      q = Cnst (_.2, [Var "x"]), 
      r = Cnst (_.2, [Cnst ("A", [])])
    );
    ...
]
\end{lstlisting}
\end{tabular}

\end{frame}
\end{comment}
%-------------------------------------------------------------------------------

\begin{frame}[fragile]\frametitle{Evaluation: Inference for Hindley-Milner Type System}
\begin{itemize}
    \item[-] Terms: 
    \begin{itemize}
        \item[-] lambda-calculus;
        \item[-] \lstinline{let}-bindings.
    \end{itemize}
    \vskip5mm
    \item[-] Type inference function:
        \vskip2mm
        \begin{itemize}
           \item[]\lstinline{val type_inference : term -> typ}
        \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}[fragile]\frametitle{Evaluation: Inference for Hindley-Milner Type System}

\begin{tabular}{l}
\begin{lstlisting}

type_inference$^o$ (=== `$\lambda x \to x$`) q $\leadsto^*$ 
  [q = `$a\to a$`]

type_inference$^o$ 
  (=== `let f = $\Box$ in f (fun x -> f x)`) `$a\to a$` $\leadsto^*$ 
  [$\Box$ = `fun $\framebox{0}$ -> $\framebox{0}$`; ...]
\end{lstlisting}
\end{tabular}

\begin{comment}

    (Let ("f", q, App(Var "f", 
       Abst("x", App(Var "f", Var "x"))))) 
    (Just TBool))

==> [
    q = Abst (_.74, Var (_.74)); 
    q = Abst (_.44, Abst (_.90, Var (_.90))); 
    q = Let (_.44, Lit (LInt (_.58)), 
        Abst (_.130, Var (_.130))); 
    ...
}

\end{comment}
\end{frame}

\begin{frame}[fragile]\frametitle{Evaluation: Inference for Hindley-Milner Type System}


\begin{tabular}{l}
\begin{lstlisting}
type_inference$^o$ (=== q) '$a$' $\leadsto^*$ 
  [] $(Does \;\, not \;\, stop, \;\, but \;\, the \;\, stream \;\, is \;\, empty)$

type_inference$^o$ (=== q) '$a$ -> $a$' $\leadsto^*$ 
  [
    q = 'fun $\framebox{0}$ -> $\framebox{0}$'; 
    q = 'fun $\framebox{0}$ -> (fun $\framebox{1}$ -> $\framebox{1}$) $\framebox{0}$'; 
    q = 'fun $\framebox{0}$ -> let $\framebox{1}$ = $\framebox{2}$ in $\framebox{0}$' ($\framebox{0}$ =/= $\;\;\framebox{1}$);
    q = '(fun $\framebox{0}$ -> $\framebox{0}$) (fun $\framebox{1}$ -> $\framebox{1}$)';
    ...
  ]
\end{lstlisting}
\end{tabular}
\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}[fragile]\frametitle{Evaluation: \miniKanren with Disequality Constraints}
\begin{itemize}    
    \item[-] Relational implementation of relational language;
    \item[-] Quite tedious to write by hand (but nevertheless was done before);
    \pause    
    \item[-] Now: disequality constraints are supported for the first time;
    \item[-] The signature of the function:
\end{itemize}
\vskip-3mm
\begin{lstlisting}
         val mk : goal -> substitution list
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]\frametitle{Evaluation: \miniKanren with Disequality Constraints}

\begin{tabular}{l}
\begin{lstlisting}

mk$^o$
  (=== 
     'let rec add a b c =
        ((a === Z) $\wedge$ (b ===  c)) $\vee$
        (fresh (a$_0$ c$_0$)
          (a === S a$_0$) $\wedge$
          $\Box$ $\wedge$
          (add a$_0$ b c$_0$)
        )
     in fresh (x y z) (add x y z)') ([[x='1'; y='1'; z='2']])
  
$\leadsto^*$ 
  
  [$\Box$ = `c ===$\;$ S c$_0$`; ...]

\end{lstlisting}
\end{tabular}

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}\frametitle{Conclusion}

\begin{itemize}
    \item[-] Typed relational conversion described and implemented.
    \item[-] Type correctness proved.
    \item[-] Semantic correctness proof is under development.
\end{itemize}

\end{frame}

\begin{comment}

\end{comment}
\end{document}
