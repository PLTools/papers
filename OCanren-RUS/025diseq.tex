% !TeX spellcheck = ru_RU
% !TEX root = main.tex

\section{Ограничения-неравенства}
\label{sec:diseq}

Зачастую для конкретной задачи пользователи расширяют реализацию реляционного программирования новыми ограничениями.
В этом разделе мы расскажем про ограничение неравенства, которое, строго говоря не обязательно, но полезно в большом круге задач.

\subsection{Задача удаления элемента из списка}

Напишем отношение, которое принимает список и искомый в нём элемент, и возвращает список без первого вхождения этого элемента.

\begin{lstlisting}
let rec rembero1 x xs out =
  conde
    [ xs === Std.nil () &&& (xs === out)
    ; fresh (h tl) (xs === Std.List.cons h tl) (h === x) (tl === out)
    ; fresh (h tl res)
        (xs === Std.List.cons h tl)
        (out === Std.List.cons h res)
        (rembero1 x tl res)
    ]
\end{lstlisting}

\noindent Реализация повторяет оригинальную~\cite{WillThesis} для Scheme. Случай пустых списков тривиален, иначе нам надо либо удалить головной элемент \verb=h=, если он равен искомому \verb=x=, либо проигнорировать головной элемент и запуститься рекурсивно для хвоста списка.

Приведенная реализация успешно удаляет первое вхождение элемента и выдает ожидаемый ответ первым.
Но если запросить с помощью \verb=run= больше ответов, то, неожиданно, они найдутся.
Дело в том, что реляционный поиск попробует воспользоваться третьей ветвью поиска даже если искомый элемент находится в голове, и поэтому реляционная программа выше вернет по ответу на каждое удаление элемента \verb=x=, а также, не удалив ни одного \verb=x=, ещё один ответ --- исходный список.

\begin{lstlisting}
run * (fun q -> rembero1 !!2 [ 1; 2; 3; 2; 4 ] q)
  -> q=[1; 3; 2; 4]
  -> q=[1; 2; 3; 4]
  -> q=[1; 2; 3; 2; 4]
\end{lstlisting}
Чтобы решить эту проблему, необходимо сделать вторую и третью ветви \verb=conde= несовместными, сказав явно в третьей ветви, что \verb=x= не может быть равен \verb=h=.
После этой модификации реляционная программа \verb=rembero2= перестанет давать неожиданные ответы.



\begin{lstlisting}
let rec rembero2 x xs out =
  conde
    [ xs === Std.nil () &&& (xs === out)
    ; fresh (h tl) (xs === Std.List.cons h tl) (h === x) (tl === out)
    ; fresh
        (h tl res)
        (xs === Std.List.cons h tl)
        (h =/= x)
        (out === Std.List.cons h res)
        (rembero2 x tl res)
    ]
\end{lstlisting}

\subsection{Реализация проверки ограничений-неравенств}



\subsection{Ограничения-неравенства и сложные типы данных}

Неаккуратное использование ограничений-неравенств для сложных типов данных может приводить к неожиданным результатам.
Рассмотрим реляционную спецификацию, которая постулирует, что переменная \verb=q= является натуральным числом (заданным в стиле Пеано) минимум с тремя конструкторами \verb=s= (следующий).
Другими словами \verb=q= $\geq 3$.

\[
\verb|fun q -> fresh (tl) (q === s (s (s tl)))|
\]

При попытке выразить обратное (число меньше трех), заменив унификацию на ограничение неравенства, мы не добьёмся ожидаемого результата, так как для любого числа $>3$ найдется такое значение логической переменной \verb=q=, что ограничение будет выполненным, т.е. его можно просто выкинуть, она не влияет на результат.
Ожидаемый результат получился бы, если бы конструкция \verb=fresh= здесь ввела бы универсально квантифицированную переменную, но она вводит экзистенциальную.
Добавление универсальной квантификации в miniKanren исследовалось~\cite{eigen}, но данный момент эффективная и корректная реализация не найдена.

Для решения этой проблемы в OCanren добавлен новый вид переменных --- шаблонные (англ.) логические переменные.
Их можно использовать на месте любого логического значения, но в реализации все шаблонные переменные представлены одинаково.


