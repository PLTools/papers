% !TEX TS-program = pdflatex
% !TeX spellcheck = en_US
% !TEX root = main.tex


\section{Introduction}
\label{sec:intro}


One of distinguishable features of \miniKanren{} is the fact that it is a family of languages:
many languages may host different \miniKanren{} implementations.
For example, faster-\miniKanren{} for \Scheme{} and \Racket{}, \CoreLogic{} for \textsc{Closure}, \OCanren{}~\cite{OCanren} for \OCaml{}, \Klogic{}~\cite{Klogic2023} for \Kotlin{} and others.
The users of these DSLs may want to compare expressive power of various flavor of miniKanren, specifics due to host language, and performance implications of choosing a different host language.


The straightforward solution is to rewrite a number of significant benchmarks for many implementation, as it done for other languages\footnote{\url{https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html}}.
Doing it manually is time consuming and error prone.
Due to low-level nature of relational programs, it is easy to make spelling mistakes, for example accidentally write wrong identifier in unification arguments.
(We did many of mistakes of this kind while porting programs from \OCanren{} to \Klogic{}.) Moreover, \miniKanren{} doesn't pardon relational programs that solve the same task: it was reported, that the order of conjuncts significantly affects~\cite{scheduling2022} performance even if the search does the same unifications.

The differences between host languages also complicate porting relational code.
For example, \Kotlin{} doesn't support currying and partial applications comparatively to \OCaml{}, and sometimes full $\eta$-expansion is needed.
Also, porting from dynamically typed languages like \Scheme{} to statically typed ones like \OCaml{} could be uneasy for newcomers to statically typed languages.
This porting could be not straightforward:
basic data representations in \OCaml{}/\Klogic{} (algebraic data types and classes with subclasses~--- sum types) is different from \Scheme{} (lists, i.e. arbitrary length tuples~--- product types).
This fact in some cases requires special constraints~\cite{Wildcards2023} to level the expressivity, and in other cases (like relational interpreters) allows to get rid of \emph{absento/symbolo} constraints.

Things could get even more complicated where we want to port larger projects which are using functional/relational approach where relational parts are intermixed with straightforward programming.
The developer is obliged to know relational approach, the original host general purpose language and to have experience  with a new host language.

In this paper we describe current status of our converter from relational \OCanren{} to \Klogic{} and \miniKanren{} in \Scheme{}.
At the moment only relational subset of \OCanren{} is supported, we don't support whole \OCaml{} language.
In next section we describe technical aspects of our approach and currently supported features.
In section \ref{sec:interpreter} we discuss transformation in relational interpreter~\cite{Untagged} from \OCanren{} to \Scheme{} and peculiarities of autogenerated implementation.


