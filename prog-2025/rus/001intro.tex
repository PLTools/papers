% !TeX encoding = windows-1251
% !TeX spellcheck = ru_RU
% !TEX root = mainrus.tex




Графические интерфейсы пользователя (GUI) — один из самых распространенных способов
взаимодействия с программами. Как на персональном компьютере, так и на ноутбуке,
мобильном телефоне, банкомате, игровой консоли и т.д. пользователь встретится с
некоторым набором графических элементов управления и интуитивно понятным смыслом.
За такой низкий порог вхождения мы платим некоторую цену: графические интерфейсы
управления не так просто разрабатывать [1, 2].

Обычные пользователи как правило не осознают, что делает графический интерфейс
приятно выглядящим и удобным в использовании. Чтобы получить качественный
интерфейс необходимо учесть множество эстетических, эргономических и психологических
аспектов, а это требует экспертизы, которой программисты обладают не всегда. Из-за этого
появляются должности не только по разработке интерфейсов (UI), но и по дизайну
взаимодействия с пользователем (UX) [3], где специалисты разрабатывают правила (англ.
guidelines) разработки хороших интерфейсов. Данные правила часто неполны,
двусмысленны и неформальны, а следование им требует интуиции, которой разработчики
могут и не обладать. Взаимодействие между разработчиками и дизайнерами часто
осложняется разницей в экспертизе, подходах и складах мышления [4].
Более того,
упомянутые
правила не всегда естественно
переносятся между разными устройствами и
даже
разрешениями
экрана.
Поэтому, чтобы поддерживать все желаемые платформы,
разработчикам придется следовать нескольких наборам правил проектирования
интерфейсов одновременно.

В данной работе представлен подход к синтезу расположения (англ. layout) элементов
управления GUI с учетом набора правил проектирования интерфейсов. Наша модель GUI
отделяет логическую структуру элементов управления (часть предельно понятная
программистам), от конкретного расположения элементов, отступов и выравниваний
(понятных дизайнеру). Мы разработали автоматический подход, который по логической
структуре (предоставляемой программистом) и набору правил (предоставленных
дизайнером) синтезирует раскладку элементов управления, удовлетворяющую этим
правилам. В общем случае правила неоднозначны, поэтому несколько конкретных
раскладок может им удовлетворять. Мы рассматриваем синтез интерфейсов как задачу
удовлетворения ограничений (англ. сonstraint satisfaction), и используем реляционное
программирование [5] и подход верификатор-из-решателя [6] (англ. verifier-to-solver), чтобы
получить решатель, располагающий элементы управления с помощью примитивов. В
примитивной форме такой решатель неэффективен, и мы применили набор оптимизаций (в
том числе специализацию), чтобы его ускорить. В результате получился решатель,
написанный на смеси из реляционного и функционального кода. Затем набор примитивов
расположения превращается в линейные ограничения на координаты и решается с
помощью SMT решателя Z3~\cite{Zthree}, что дает нам абсолютные координаты всех элементов
управления. Этот подход позволяет получить корректный и полный решатель: по указанной
логической структуре он синтезирует все расположения элементов, удовлетворяющие
правилам дизайна.

При этом решатель достаточно эффективен, чтобы запускаться на обычном ноутбуке.
