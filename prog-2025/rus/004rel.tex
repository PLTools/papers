% !TeX spellcheck = ru_RU
% !TEX root = mainrus.tex

\section{Реляционное программирование, верификаторы и решатели}
\label{sec:rel}

Реализация синтеза интерфейсов использует реляционное программирование. В этом разделе мы кратко расскажем, что это такое, и как работает наш инструмент.

%The implementation of our layout synthesizer employs the techniques of relational programming. Here
%we briefly recollect what relational programming is and how the approaches and tools we use work.

Реляционное программирование~\cite{TRS} --- это подход, основанный на идее описания программ как отношений.
Его можно рассматривать как вид логического программирования, в котором порицается использование всех не реляционных конструкций (эффекты, не логические конструкции).
В узком смысле реляционное программирование --- это написание программ на \textsc{miniKanren}~--- специально сконструированном для этих целей, встраиваемом предметно-ориентированном языке. В оригинале он разрабатывался для \textsc{Scheme}/\textsc{Racket}, позже \textsc{miniKanren} был портирован на другие языки\footnote{\url{http://minikanren.org/\#implementations} (проверено: \DTMDate{2024-08-26})}}.
Мы используем строго статически типизированную реализацию \textsc{miniKanren}, встроенную в \textsc{OCaml}, которая называется \textsc{OCanren}~\cite{OCanren}.
В \textsc{miniKanren} используется та же теория дизъюнктов Хорна как и в \textsc{Prolog}, но с другим синтаксисом: явные унификации и дизъюнкции, конъюнкции, явное создание свежих (англ. fresh) переменных, а также  используется стратегия \emph{поиска с чередованием} (англ. interleaving search)~\cite{interleaving}, которая полна~\cite{certified}.
Кроме унификации с проверкой цикличности вхождений (англ. occurs-check) по-умолчанию, \textsc{miniKanren} можно оснастить другими ограничениями, например: неравенства~\cite{disuni}, конечные домены~\cite{cKanren} или конструкции из номинальной логики~\cite{aKanren}.


%Relational programming~\cite{TRS} is an approach based on the idea of describing programs as
%relations. It can be considered as a branch of logic programming in which the use of
%all non-relational constructs (side-effects, extra-logic features) is discouraged. In a
%narrow sense relational programming amounts to writing programs in \textsc{miniKanren}~--- a
%specifically designed for this purpose embedded DSL. Initially developed for \textsc{Scheme}/\textsc{Racket}
%\textsc{miniKanren} later was ported for dozens of host
%languages\footnote{\url{http://minikanren.org/\#implementations}}.
%We, specifically, use a strongly typed \textsc{miniKanren} implementation for \textsc{OCaml}~\cite{ocaml}, called \textsc{OCanren}~\cite{OCanren}.
%\textsc{miniKanren} uses the same theory of Horn clauses as \textsc{Prolog} but with a different
%concrete syntax with explicit unification, conjunction, disjunction and fresh variable introduction, and
%employs a different \emph{interleaving} search strategy~\cite{interleaving}, which is known to be complete~\cite{certified}.
%Besides unification with occurs-check, enabled by default, \textsc{miniKanren} can be equipped with other
%basic constraints like disequality constraint~\cite{disuni}, finite-domain constraints~\cite{cKanren}, or
%constructs of nominal logic~\cite{aKanren}.

В контексте нашей работы, самым важным свойством \textsc{miniKanren} является возможность выражения \emph{обратимых вычислений}.
Известно~\cite{SemanticsModifiers,SemanticsModifiers1}, что некоторые сложные программы могут быть построены как результат обращения некоторых других более простых программ. В частности, \emph{решатель} задачи поиска можно рассматривать как обращение программы, которая проверяет корректность ответа (англ. \emph{verifier}).
Широко известно, что задача проверки корректности решения, как правило, гораздо проще задачи поиска корректного решения.
Реляционная природа \textsc{miniKanren} позволяет осуществлять обратимые вычисления очень просто, что помогает в задачах синтеза программ~\cite{Untagged,WBirdSeven,PatternMatching}.

%In the context of our work the most valuable property of \textsc{miniKanren} is its capability of expressing \emph{reverse computations}.
%It is well-known~\cite{SemanticsModifiers,SemanticsModifiers1} that some complicated programs can be constructed as
%the results of inversion of some other, much simpler, programs. In particular, a \emph{solver} for a
%certain search problem can be considered as an inversion of its \emph{verifier}; it is rather a matter of common knowledge that verifying a
%solution is, as a rule, much easier than finding one. The relational nature of \textsc{miniKanren} makes
%inverse computations particularly easy~\cite{searchproblems}, which opens a way for program
%synthesis~\cite{Untagged,WBirdSeven,PatternMatching}.

Другим компонентом нашего подхода является \emph{реляционное преобразование} (англ. \emph{relational conversion}).
Во многих случаях (но не всегда) проще получить реляционную спецификацию из кода на функциональном языке, чем написать спецификацию вручную.
Мы используем инструмент \textsc{noCanren}, который преобразует программы, написанные на подмножестве \textsc{OCaml}, в  \textsc{OCanren}-спецификации, корректные по построению.

%Another component of our approach is \emph{relational conversion}. In many cases (but not always!) it is easier to obtain a relational specification
%from functional program than writing the one by hands. We use a tool, called \textsc{noCanren}, which converts programs written is a reasonable
%subset of \textsc{OCaml} into correct-by-construction\cite{conversion} \textsc{OCanren} specifications.

Продемонстрируем наш подход на следующем обозримом примере. Рассмотрим программу на рис.~\ref{fun_vs_rel}\subref{funadd}, которая складывает два натуральных числа в форме Пеано. Её реляционный образ, полученный с помощью реляционного преобразования (не буквально, но в эквивалентной записи)~--- на рис. ~\ref{fun_vs_rel}\subref{reladd}.
Сравнивая их, можно обратить внимание, что сопоставление с образцом было заменено на дизъюнкцию (\lstinline[language=ocanren,basicstyle=\small]|\/|)
и унификацию  (\lstinline[language=ocanren,basicstyle=\small]|===|); модификации потока данных --- на конъюнкцию (\lstinline[language=ocanren,basicstyle=\small]|/\|); свежие переменные были добавлены, где это необходимо; а постфиксная нотация ``$^o$'' традиционно используется для обозначения определения реляций (вычислимых отношений).
В отличие от функциональной реализации, у реляционной три аргумента (\lstinline[language=ocanren,basicstyle=\small]|x|, \lstinline[language=ocanren,basicstyle=\small]|y|,
и \lstinline[language=ocanren,basicstyle=\small]|z|), каждый из которых может содержать  свежие переменные.
Вычисление конструкции  \lstinline[language=ocanren,basicstyle=\small]|run$^*$ {add$^o$ x y z}| возвращает \emph{ленивый поток ответов}, который содержит все подстановки этих трёх переменных, такие, что отношение $\{(x,y,z)\in\mathbb{N}^3 \mid x+y=z\}$ верно.
Этот поток можно исследовать в OCaml, чтобы получать ответы по-одному. Одна и та же спецификация может использоваться и для сложения, и для вычитания, и для разбиения числа на два слагаемых.

%We demonstrate the roadmap of our approach by the following observable example. Let us have a program
%shown in Fig.~\ref{fun_vs_rel}\subref{funadd} which adds two natural numbers in Peano form. Its relational counterpart,
%acquired via relational conversion (not literally, but in equivalent form), is shown in Fig.~\ref{fun_vs_rel}\subref{reladd}.
%Comparing both of them we can notice that pattern-matching was replaced by disjunction (\lstinline[language=ocanren,basicstyle=\small]|\/|)
%and unification (\lstinline[language=ocanren,basicstyle=\small]|===|), data-flow dependent computations with conjunction (\lstinline[language=ocanren,basicstyle=\small]|/\|),
%and fresh variables can be allocated when needed; the postfix ``$^o$'' is traditionally used to distinguish relational definitions. Unlike its functional
%counterpart the relational specification has \emph{three} arguments \lstinline[language=ocanren,basicstyle=\small]|x|, \lstinline[language=ocanren,basicstyle=\small]|y|,
%and \lstinline[language=ocanren,basicstyle=\small]|z|, each of which can contain fresh (initially undefined) variables.
%The evaluation of construction \lstinline[language=ocanren,basicstyle=\small]|run$^*$ {add$^o$ x y z}| returns all substitutions for these
%fresh variables which make the relation $\{(\mbox{\texttt x}, \mbox{\texttt y}, \mbox{\texttt z})\in\mathbb{N}^3\, |\, \mbox{\texttt x+y=z}\}$ hold, represented as a \emph{lazy stream of answers}. This stream can
%then be inspected in a host functional application to retrieve individual answers. Thus the same specification can be equally used for plain addition,
%subtraction or decomposition of a number into two summands.

\begin{figure}[t]
  \begin{subfigure}[t]{0.5\textwidth}
  \begin{lstlisting}[language=ocanren,basicstyle=\small]
   let rec add x y =
     match x with
     | O    -> y
     | S xp -> S (add xp y)
  \end{lstlisting}
  %\vskip12mm
  \caption{Реализация на функциональном языке}
  \label{funadd}
  \end{subfigure}
  \begin{subfigure}[t]{0.5\textwidth}
    \begin{lstlisting}[language=ocanren,basicstyle=\small]
  let rec add$^o$ x y z = ocanren {
    x === O /\ z === y \/
    fresh xp, zp in
      x === S xp /\
      z === S zp /\
      add$^o$ xp y zp
  }
    \end{lstlisting}
    \caption{Реляционное сложение}
    \label{reladd}
  \end{subfigure}
  \caption{Функциональное и реляционное сложение чисел Пеано }
  \label{fun_vs_rel}
\end{figure}
